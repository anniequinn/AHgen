---
title: "2 - Loading inputs"
author: 
 - Annie Visser-Quinn & Melissa Bedinger
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    toc_float: true
    toc_depth: 3
    theme: paper
    highlight: haddock
vignette: >
  %\VignetteIndexEntry{2 - Loading inputs}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
```{r setup, include = FALSE}

knitr::opts_chunk$set(echo = TRUE, cache = TRUE, message = FALSE, warning = FALSE)

rm(list = ls()); cat("\014")

library(knitr)
library(tidyverse)
library(igraph)
library(AHgen)
```

<style>
#TOC {
  background: url("images/hex.png");
  background-size: 230px;
  background-position-x: center;
  background-position-y: top;
  padding-top: 280px !important;
  background-repeat: no-repeat;
}
</style>

---

In the vignette below, you will find out about data in AHgen. This vignette is associated with v1.0.

- Section 1 - Data types
- Section 2 - Read in data using the `read_*` family of functions
- Section 3 - Convert to different data types using the conversion family of functions
- Section 4 - Navigating the data using the `tidyverse` and `igraph` packages

You can jump to a specific section using the buttons on the left.

## 1. Data types

### 1.1 Adjacency matrix

An [**adjacency matrix**](https://proofwiki.org/wiki/Definition:Adjacency_Matrix) is a matrix which describes a network by representing which vertices are adjacent (i.e. connected) to which other vertices. If there are N vertices in a network, there are N columns (one for each vertex) and N rows (one for each vertex) in the matrix. Each cell of the matrix includes number signifying the connection between the two vertices, representing a potential edge or link.

An adjacency matrix for a simple graph has elements which are all either 0 (representing no connection between the two vertices) or 1 (representing a connection between the two vertices). This is a binary representation of a network. An adjacency matrix for a weighted network contains the weights of the edges (e.g. a weight of 0.75). A higher weight represents a stronger connection than a lower weight (e.g. an edge with a weight of 0.75 is stronger than an edge with a weight of 0.25).

Abstraction Hierarchies are treated as undirected graphs, thus an adjacency matrix for an Abstraction Hierarchy is symmetrical about the main diagonal.

*An example adjacency matrix*
```{r, echo = FALSE}
htmltools::img(src = knitr::image_uri("images/2 - Loading inputs/mobility_adjMat.png"), 
               alt = 'Adjacency Matrix XLSX', width = 800)
```

<br>

### 1.2 Edgelist 

An [**edge list**](https://en.wikipedia.org/wiki/Edge_list) is a data structure which describes a network by listing each connection as a row of information. The first column describe the vertex the edge is coming 'from', the second column describes the vertex the edge is coming 'to', and if it is a weighted network the third column gives the numeric value of the 'weight'. In an undirected network such as the Abstraction Hierarchy, the 'from' and 'to' columns are merely representative of an undirected edge between two vertices rather than literally being 'from' and 'to' one vertex or another.

*An example edge list*
```{r, echo = FALSE}
htmltools::img(src = knitr::image_uri("images/1 - Data/mobility_edges.png"), 
               alt = 'Edges XLSX', width = 500)
```

<br>

### 1.3 igraph

An **igraph** is an object class from the package of the same name. The igraph data type is a **special way of formatting complex networks**, enabling the creation of large networks and speedy application of network analysis. 

The code output below is an **igraph of an abstraction hierarchy**.

```{r echo = FALSE}
dh = read_adjMat("../inputs/microwaveAH_adjMat_20230629.xlsx") 
dv = dh %>% select(level, levelName_full, levelName, Node)
di = dh %>% adjMat_to_igraph(vInfo = dv)
di
```
The first line states that this is an igraph. It also provides a codename for the graph, *UNW-*:

- **U** The graph is **U**ndirected
- **N** The vertices have **N**ames
- **W** The **W**eight attribute has been set
- **-** The graph is not bipartite

The second line provides the attributes of the **vertices** (denoted as **v**) and **edges** (denoted as **e**):

- **name (v/c)** The vertices are named, and have the class **c**, character.
- **level (v/n)** The vertices have an attribute called **level**, with the class **n**, numeric. This denotes which level (from 1 through 5) a vertex belongs to.
- **levelName_full (v/c)** The vertices have an attribute called **levelName_full**, with the class **c**, character. This gives the full level name in human factors and Cognitive Work Analysis terminology (from 'Functional purposes' through 'Physical objects').
- **levelName (v/c)** The vertices have an attribute called **levelName**, with the class **c**, character. This gives a more concise level name (from 'Purposes' through 'Resources').
- **weight (e/n)** The edges have a weight, with the class **n**, numeric.
- **layer (e/c)** The edges have an attribute called **layer**, with the class **c**, character.

The remainder of the output represents the edges and the vertex names. 

<br>

## 2. Reading in the data

Here we focus on the two functions, `read_adjMat()` and `read_vInfo()`, which read in the main inputs to AHgen:

- An **adjacency matrix** capturing the edges between the levels of the abstraction hierarchy.

- **Vertex information**, the level and level name associated with each vertex.

These inputs should be in the .xlsx format, i.e. an Excel spreadsheet.

<br>

### 2.1 Adjacency matrix

The adjacency matrix can be read in using the function `read_adjMat()`. This function has three input arguments:

- `filename` The file path (relative to the AHgen folder).

- `sheet` The sheet number of the adjacency matrix; this is set to **1 by default**.

- `rescale` Whether the edge weightings in the adjacency matrix should be rescaled to 0.5; this is set to **FALSE by default**.

*Note, two of the three `read_adjMat()` input arguments have default values. If only the filename is provided, these arguments will take this default value.*

Click below to explore two example applications.

<details><summary><span style = "color: #2196F3;">**Show code - Example 1**</span></summary>
The classic human factors example of cooking food in a microwave. The Excel file, *microwaveAH_adjMat_20230629.xlsx* is provided in the *inputs* folder. An annotated exert of the adjacency matrix is shown below.

<span style="color: red;">Add image here.</span>

1. The column of vertex names must be named **Node**.
2. Vertex names run left to right.
3. And top to bottom.
4. The **edges** between vertices are **denoted by 1**. **Non-edges** are denoted by **empty** cells. *Note, zeroes can also be used to indicate non-edges*.
5. The diagonal cannot be linked, **a vertex cannot link to itself**.

```{r }
read_adjMat("../inputs/microwaveAH_adjMat_20230629.xlsx")
```

Notice that the empty cells from the Excel file are filled with zeroes by AHgen. This means these vertices are not linked, i.e. they have no weight. We might want to rescale the linked, or weighted edges, to 0.5. To do this, change the `rescale` argument to `TRUE`.

```{r}
read_adjMat("../inputs/microwaveAH_adjMat_20230629.xlsx", rescale = TRUE)
```
</details>


<details><summary><span style = "color: #2196F3;">**Show code - Example 2**</span></summary>

We now consider a second example abstraction hierarchy, *mobilityAH_adjMat_20230629.xlsx*, which is also available in the *inputs* folder.

<span style="color: red;">Add image here.</span>

1. As before, the column of vertex names is called **Node**.
2. And the vertex names run left to right.
3. And top to bottom.
4. The **edges** between vertices are again **denoted by 1**. This time, **non-edges** are denoted by **0** cells.
5. But there are three extra columns of vertex information, **level**, **levelName_full**, and **levelName**. If these columns had different names they would be read in as vertices!

With only one sheet, the first sheet is the adjacency matrix, and if we don't want to rescale the data, then only one input argument is required `"../inputs/mobilityAH_adjMat_20230629.xlsx"`.

```{r}
read_adjMat("../inputs/mobilityAH_adjMat_20230629.xlsx")
```

The code chunk below shows what happens if there is a mismatch in column names. Check out the file *mobilityAH_error_adjMat_20230629.xlsx* to see if you can spot the problem.

```{r, error = TRUE}
read_adjMat("../inputs/mobilityAH_error_adjMat_20230629.xlsx")
```
</details>

<br>

### 2.2 Vertex information
The vertex information can be read in using the function `read_vInfo()`. This function has two input arguments:

- `filename` The file path (relative to the AHgen folder)

- `sheet` The sheet number of the vertex information. This is set to **1 by default**

<details><summary><span style = "color: #2196F3;">**Show code - Example 3**</span></summary>

For the microwave AH, the vertex information is in the second sheet. Each row describes a single vertex in terms of level, level name (full), level name, and vertex name. To avoid errors, these columns must be named **level**, **levelName_full**, **levelName** and **Node**. 

<span style="color: red;">Add image here.</span>

```{r}
read_vInfo("../inputs/microwaveAH_vInfo_20230629.xlsx")
```
</details>

<details><summary><span style = "color: #2196F3;">**Show code - Example 4**</span></summary>

We saw in **Example 2** that the vertex information was embedded in the adjacency matrix. This can be extracted using the `tidyverse` `select` function.

```{r}
read_adjMat("../inputs/mobilityAH_adjMat_20230629.xlsx") %>% 
  select(level, levelName_full, levelName, Node)
```
</details>

<br>

## 3. Checking the data

Demo check functions

```{r}
# Confirm adjMat has completely symmetrical edges i.e. there are no input errors
dh %>% checkSymmetry()

# Confirm adjMat has no vertices with redundant sets of edges i.e. no vertices
# are connected to the same set of other vertices between two levels
dh %>% checkRedundancy()
```

<br>

## 4. Converting the data
In AHgen, the abstraction hierarchy can be captured in three different formats:

- Adjacency matrix
- Edge list
- igraph

To change format, AHgen has a family of six conversion functions:

- `adjMat_to_edgelist()` and `adjMat_to_igraph()`, where the input arguments are the adjacency matrix
- `edgelist_to_igraph()` and `edgelist_to_adjMat()`, where the input arguments are the abstraction hierarchy in edge list format, and the vertex information
- `igraph_to_adjMat()` and `igraph_to_edgelist()`, where the input arguments are the abstraction hierarchy in the igraph format

Before introducing the examples, we need to save the adjacency matrix and vertex information as objects in the environment. We do this using the `<-` or `=` operator.

```{r}
dh = read_adjMat("../inputs/mobilityAH_adjMat_20230629.xlsx") 
dv = dh %>% select(level, levelName_full, levelName, Node)
```

<details><summary><span style = "color: #2196F3;">**Show code - Example 5 - From adjacency matrix**</span></summary>
```{r}
de = dh %>% adjMat_to_edgelist(vInfo = dv); de
di = dh %>% adjMat_to_igraph(vInfo = dv); di
```
</details>

<details><summary><span style = "color: #2196F3;">**Show code - Example 6 - From edge list**</span></summary>
Note that, when converting from an edge list, we need to specify the vertex information. 

```{r}
de %>% edgelist_to_igraph(vInfo = dv)
de %>% edgelist_to_adjMat(vInfo = dv)
```
</details>

<details><summary><span style = "color: #2196F3;">**Show code - Example 7 - From igraph**</span></summary>
```{r}
di %>% igraph_to_adjMat
di %>% igraph_to_edgelist
```

<br>

## 5. Navigating the data

Now let's consider how to navigate and explore these three data types.

- The **adjacency matrix** and **edge list** are in a **tibble** format, an easy to read tabular form. They can be navigated like any data.frame or tibble in R using functions such as `select()` and `filter()`.
- The **igraph** is a special way of formatting complex networks. The package of the same name introduces a number of functions to interrogate the network.

Click below for examples for each data type. 

<details><summary><span style = "color: #2196F3;">**Show code - Example 8 - Adjacency matrix**</span></summary>
```{r}
# Select vertices by name
dh %>% select(`Provide efficient and accessible mobility`)

# Select vertices which match a pattern
dh %>% select(Node, contains("safe"))

# Filter to a specific vertex
dh %>% filter(Node == "Compliant user behaviour")

# Filter to vertices matching a pattern
dh %>% filter(str_detect(Node, "capab|Capab"))
```
</details>

<details><summary><span style = "color: #2196F3;">**Show code - Example 9 - Edge list**</span></summary>

```{r}
# Filter for edges in a specific layer
de %>% filter(layer == "l1FP_l2VPM")

# Filter for edges linking vertices containing road
de %>% filter_all(any_vars(str_detect(str_to_lower(.), "road")))

# Filter for edges linking from the vertex "Vehicle capacity"
de %>% filter(from == "Vehicle capacity")
```
</details>

<details><summary><span style = "color: #2196F3;">**Show code - Example 10 - igraph**</span></summary>
```{r}
# Extract vertices
V(di)

# Extract edges
E(di)

# Extract vertex attribute name
V(di)$name

# Extract vertex attribute level
V(di)$level

# Extract vertex attribute levelName_full
V(di)$levelName_full

# Extract vertex attribute levelName
V(di)$levelName

# Extract edge attribute weight
E(di)$weight

# Extract edge attribute layer
E(di)$layer
```
</details>

<br>

## Last updated
This vignette is associated with AHgen v1.0.0.0, and was last updated by Melissa Bedinger on `r Sys.Date()`.